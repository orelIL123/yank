# RLS, Tests ו-JSONB – הסבר והמלצות (בלי לשבור את האפליקציה)

מסמך זה מסביר את שלושת הנושאים מהסקירה המקצועית ונותן המלצות שלא משנות התנהגות של האפליקציה.

---

## 1. מדיניות RLS חלשה – כל משתמש מחובר יכול לערוך תוכן

### מה הבעיה?

ב-Supabase יש **Row Level Security (RLS)** – כלומר כל שורה בטבלה יכולה להיות מותנית ב"מי המבצע". כרגע ה-policies מוגדרים בערך כך:

- **SELECT (קריאה)**: כולם יכולים לקרוא – `USING (true)`.
- **INSERT / UPDATE / DELETE**: "Authenticated users can..." אבל עם `WITH CHECK (true)` / `USING (true)`.

בפרויקט הזה האימות הוא ב-**Firebase Auth**, וה-client מדבר עם Supabase רק עם **מפתח anon**. ב-Supabase אין "משתמש מחובר" – כל הבקשות מגיעות כאילו anonymous.  
לכן ב-Supabase:

- `auth.uid()` לא רלוונטי (אין Supabase Auth).
- ה-policy "Authenticated users can insert/update/delete" בפועל מאפשרת **לכל מי שיש לו את ה-anon key** לבצע כתיבה (כי התנאי הוא `true`).

כלומר: מי שיש לו את ה-anon key (למשל מחקירת רשת או מהאפליקציה) יכול לשלוח INSERT/UPDATE/DELETE ישירות ל-Supabase, בלי להיות "אדמין" באפליקציה. האפליקציה בודקת אדמין רק ב-UI (למשל `userRole === 'admin'`), אבל המסד לא בודק.

### למה לא "פשוט נגביל ב-RLS"?

כדי ש-RLS יגביל לפי "אדמין", Supabase צריך לדעת "מי המבצע". האפשרויות:

1. **Supabase Auth** – אם כל המשתמשים היו מתחברים דרך Supabase, אפשר ב-RLS לבדוק `auth.uid()` ו/או role. אצלכם הלוגין הוא ב-Firebase, אז Supabase "לא רואה" את המשתמש.
2. **Edge Function + Service Role** – האפליקציה שולחת בקשות כתיבה (רק ממסכי אדמין) ל-Edge Function; הפונקציה בודקת את ה-Firebase token ואת רשימת האדמינים, ואם הכל תקין – כותבת ל-DB עם **service_role**. במצב כזה אפשר להשאיר ל-anon key **רק SELECT** (קריאה), ואז גם אם מישהו גונב את ה-anon key הוא לא יכול לערוך תוכן.

### מה לעשות בלי לשבור כלום

- **כרגע**: לא משנים RLS. האפליקציה ממשיכה לעבוד כמו היום.  
  חשוב להבין: האבטחה נשענת על כך ש:
  - רק אדמין רואה מסכי עריכה באפליקציה.
  - ה-anon key ממילא נחשף ב-client (כל אפליקציה מובייל/ווב חושפת אותו), ולכן הגנה "אמיתית" על כתיבה חייבת להיות בצד שרת (למשל Edge Function).
- **בעתיד**: אם תרצו לחזק – מעבירים את כל פעולות הכתיבה של אדמין (הוספה/עדכון/מחיקה של ספרים, חדשות, תפילות וכו') ל-**Edge Function** שמאמתת Firebase token + רשימת אדמין, וכותבת עם service_role. רק אחרי שזה מוכן – מעדכנים את ה-RLS כך ש-anon יוכל רק **SELECT** על הטבלאות האלו. זה לא שובר את האפליקציה כי הכתיבה כבר תעבור דרך הפונקציה.

סיכום: **אין שינוי קוד או RLS במסמך הזה** – רק הסבר ו-roadmap. האפליקציה נשארת עובדת מעולה כמו היום.

---

## 2. Test files – מה זה ואיך בודקים?

### מה זה Tests (בדיקות)?

- **Unit tests**: בודקים פונקציה או מודול בודד (למשל `toSnakeCase`, פונקציות עזר ב-`database.js`) בלי להריץ את כל האפליקציה.
- **Integration tests**: בודקים כמה חלקים together (למשל שירות + mock של Supabase).
- **E2E (End-to-End)**: בודקים את האפליקציה כמו משתמש – לחיצות, ניווט, טעינת מסכים.

ערך: אחרי שינוי קוד, מריצים את ה-tests. אם הם עוברים – סביר שהשינוי לא שובר לוגיקה קיימת. אם משהו נשבר – מתקנים לפני שמעלים גרסה.

### איך עושים בפרויקט React Native / Expo?

סטנדרט:

- **Jest** – מנוע הבדיקות (הרצה, assertions).
- **React Native Testing Library** – רינדור קומפוננטות ו-"אינטראקציות" (למשל `fireEvent`) בסביבה דמוית React Native.

בפרויקט נוספו:

- תיקיית `__tests__` עם קובץ דוגמה אחד (למשל לבדיקת לוגיקה פשוטה או ל-database service עם mock).
- סקריפט ב-`package.json`: `"test": "jest"` (או `jest --passWithNoTests` אם אין עדיין tests).

איך להריץ:

```bash
cd native
npm test
```

זה **לא נוגע** בקוד האפליקציה עצמה – רק מוסיף קבצי test וסקריפט. האפליקציה ממשיכה לרוץ כרגיל עם `npx expo start`.

### מה כבר נוסף (קונקרטית)

- קובץ דוגמה: `native/__tests__/example.test.js` – בודק משהו פשוט (למשל פונקציית עזר או שהשירות מחזיר מבנה נכון עם mock).
- במידה ו-Jest עדיין לא מוגדר – נוסף `jest.config.js` מינימלי ו-`"test": "jest"` ב-`package.json`.

כשתרצה להרחיב – תוסיף קבצי `*.test.js` / `*.test.jsx` ל-`__tests__` או ליד הקבצים שהם בודקים.

---

## 3. שימוש ב-JSONB במקום עמודות רגילות – לא אופטימלי

### מה המצב היום?

- בקוד: **`database.js`** מניח שכל טבלה כוללת עמודה **`data`** מסוג **JSONB**, וכל השדות (title, content, וכו') שמורים בתוך האובייקט הזה. הקוד עושה `row.data` ומחזיר `{ id: row.id, ...row.data }`.
- ב-`supabase-schema.sql`: מופיעות טבלאות עם **עמודות רגילות** (למשל `title`, `description`, `content` וכו') – בלי עמודת `data`.

אז יש שני מצבים אפשריים:

1. **אם ב-DB האמיתי הטבלאות הן עם `id` + `data` (JSONB)**  
   - אז ה-schema ב-repo לא משקף את ה-DB, וה-app תואם ל-JSONB.
2. **אם ב-DB יש עמודות רגילות**  
   - אז ה-`database.js` שכותב/קורא `row.data` לא יתאים למבנה הנוכחי (אלא אם יש גם עמודת `data` שממולאת).

### למה JSONB פחות אופטימלי?

- **ביצועים**: שאילתות על שדה ב-JSONB (למשל `data->>'title'`) בדרך כלל פחות יעילות מעמודה רגילה עם אינדקס.
- **אינדקסים**: קל יותר ליצור אינדקס על עמודה רגילה; על JSONB צריך ביטויים מיוחדים.
- **תחזוקה**: טיפוסים ו-constraints ברורים יותר על עמודות רגילות.

### מה להציע – בלי לשבור כלום

- **לא משנים** כרגע את מבנה ה-DB ולא את `database.js` – האפליקציה נשארת עובדת.
- **המלצה לעתיד** (שלב־שלב):
  1. **להבהיר** איך הטבלאות באמת נראות ב-Supabase (עמודות רגילות בלבד, או `id` + `data` JSONB).
  2. **אם יש JSONB ורוצים לעבור לעמודות**:
     - להוסיף עמודות רגילות לאותן טבלאות (במקביל ל-`data`).
     - לכתוב סקריפט migration שממלא את העמודות מתוך `data`.
     - לעדכן את `database.js` טבלה־טבלה לקרוא/לכתוב מהעמודות הרגילות.
     - אחרי שכל הקריאות/כתיבות עוברות לעמודות – להפסיק שימוש ב-`data` ולהוריד את העמודה (אופציונלי).
  3. **אם כרגע יש רק עמודות רגילות** – לעדכן את `database.js` כך שיעבוד עם העמודות האלו (בלי `row.data`), ולוודא שכל השדות הנדרשים קיימים ב-schema.

כל שלב אפשר לעשות על טבלה אחת, לבדוק שהאפליקציה עובדת, ורק אז להמשיך לאחרות.

---

## סיכום

| נושא        | מה עשינו עכשיו                         | מה אפשר לעתיד בלי לשבור |
|------------|----------------------------------------|---------------------------|
| **RLS**    | רק הסבר + הבהרה שלא משנים RLS         | מעבר כתיבת אדמין ל-Edge Function ואז הגבלת anon ל-SELECT |
| **Tests**  | הסבר + דוגמת test אחת + סקריפט `npm test` | להוסיף עוד `*.test.js` על לוגיקה ומודולים חשובים |
| **JSONB**  | רק הסבר + המלצה למסלול מעבר           | migration לעמודות רגילות טבלה־טבלה + עדכון `database.js` בהדרגה |

האפליקציה ממשיכה לעבוד מעולה; שום שינוי כאן לא שובר התנהגות קיימת.
